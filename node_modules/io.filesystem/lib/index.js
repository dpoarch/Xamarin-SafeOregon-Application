var // Copyright (c) 2014 Quildreen Motta
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
/**
 * Monadic wrapper on Node's fs library
 *
 * @module io.filesystem
 * @summary FileSystem → IO.FileSystem
 */
Future = require('data.future');
var curry = require('core.lambda').curry;
var __ref = require('control.monads');
var filterM = __ref.filterM;
var __ref$2 = require('control.async')(Future);
var parallel = __ref$2.parallel;
var adt = require('adt-simple');
var path = require('path');
var mv = require('mv');
var prepend = function (a) {
    return function (b) {
        return path.join(a, b);
    };
};
var flatten = function (xs) {
    return xs.reduce(function (a, b) {
        return a.concat(b);
    }, []);
};
module.exports = function (fs) {
    var exports = {};
    var LinkType = function () {
        /**
   * @summary Directory | File | Junction
   */
        function LinkType$2() {
        }
        function Directory$2() {
        }
        Directory$2.prototype = new LinkType$2();
        Directory$2.prototype.constructor = Directory$2;
        function File$2() {
        }
        File$2.prototype = new LinkType$2();
        File$2.prototype.constructor = File$2;
        function Junction$2() {
        }
        Junction$2.prototype = new LinkType$2();
        Junction$2.prototype.constructor = Junction$2;
        var derived = adt.Base.derive({
            name: 'LinkType',
            constructor: LinkType$2,
            prototype: LinkType$2.prototype,
            variants: [
                {
                    name: 'Directory',
                    constructor: Directory$2,
                    prototype: Directory$2.prototype
                },
                {
                    name: 'File',
                    constructor: File$2,
                    prototype: File$2.prototype
                },
                {
                    name: 'Junction',
                    constructor: Junction$2,
                    prototype: Junction$2.prototype
                }
            ]
        });
        LinkType$2.Directory = new derived.variants[0].constructor();
        LinkType$2.File = new derived.variants[1].constructor();
        LinkType$2.Junction = new derived.variants[2].constructor();
        return LinkType$2;
    }();
    var Directory = LinkType.Directory;
    var File = LinkType.File;
    var Junction = LinkType.Junction;
    ;
    exports.LinkType = LinkType;
    /**
   * Tests if a path exists.
   *
   * @method
   * @summary Pathname → Future[Void, Boolean]
   */
    exports.exists = exists;
    function exists(p) {
        return new Future(function (reject, resolve) {
            fs.exists(p, function (a) {
                resolve(a);
            });
        });
    }
    exports.rename = curry(2, rename);
    function rename(a, b) {
        return new Future(function (reject, resolve) {
            fs.rename(a, b, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.changeOwner = curry(3, changeOwner);
    function changeOwner(p, owner, group) {
        return new Future(function (reject, resolve) {
            fs.chown(p, owner, group, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.changeMode = curry(2, changeMode);
    function changeMode(p, mode) {
        return new Future(function (reject, resolve) {
            fs.chown(p, mode, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.symlink = curry(3, symlink);
    function symlink(type, a, b) {
        return new Future(function (reject, resolve) {
            fs.symlink(a, b, renderType(type), function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
        function renderType(a$2) {
            return function (a0) {
                if (Directory.hasInstance ? Directory.hasInstance(a0) : a0 instanceof Directory) {
                    return 'dir';
                }
                if (File.hasInstance ? File.hasInstance(a0) : a0 instanceof File) {
                    return 'file';
                }
                if (Junction.hasInstance ? Junction.hasInstance(a0) : a0 instanceof Junction) {
                    return 'junction';
                }
                throw new TypeError('No match');
            }.call(this, a$2);
        }
    }
    exports.readLink = readLink;
    function readLink(a) {
        return new Future(function (reject, resolve) {
            fs.readlink(a, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.realPath = realPath;
    function realPath(a) {
        return new Future(function (reject, resolve) {
            fs.realPath(a, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.stat = stat;
    function stat(a) {
        return new Future(function (reject, resolve) {
            fs.stat(a, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.isFile = isFile;
    function isFile(a) {
        return function () {
            var $do$op = stat(a);
            var $do$type = $do$op.of || $do$op.constructor.of;
            return $do$op.chain(function (stats) {
                return $do$type(stats.isFile());
            });
        }();
    }
    exports.isDirectory = isDirectory;
    function isDirectory(a) {
        return function () {
            var $do$op = stat(a);
            var $do$type = $do$op.of || $do$op.constructor.of;
            return $do$op.chain(function (stats) {
                return $do$type(stats.isDirectory());
            });
        }();
    }
    exports.read = curry(2, read);
    function read(options, a) {
        return new Future(function (reject, resolve) {
            fs.readFile(a, options, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.readAsText = exports.read({ encoding: 'utf8' });
    /**
   * @method
   * @summary Options → Pathname → String → Future[Error, Void]
   */
    exports.write = curry(3, write);
    function write(options, a, data) {
        return new Future(function (reject, resolve) {
            fs.writeFile(a, data, options, function (err, data$2) {
                if (err)
                    reject(err);
                else
                    resolve(data$2);
            });
        }.bind(this));
    }
    exports.writeAsText = exports.write({ encoding: 'utf8' });
    /**
   * @method
   * @summary Options → Pathname → String → Future[Error, Void]
   */
    exports.append = curry(3, append);
    function append(options, a, data) {
        return new Future(function (reject, resolve) {
            fs.appendFile(a, data, options, function (err, data$2) {
                if (err)
                    reject(err);
                else
                    resolve(data$2);
            });
        }.bind(this));
    }
    function removeFile(a) {
        return new Future(function (reject, resolve) {
            fs.unlink(a, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    function removeDirectory(a) {
        return new Future(function (reject, resolve) {
            fs.rmdir(a, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.remove = remove;
    function remove(a) {
        return function () {
            var $do$op = stat(a);
            var $do$type = $do$op.of || $do$op.constructor.of;
            return $do$op.chain(function (stats) {
                return stats.isFile() ? removeFile(a) : stats.isDirectory() ? removeDirectory(a) : /* otherwise */
                Future.rejected(new Error('Can only remove files or directories'));
            });
        }();
    }
    exports.makeDirectory = curry(2, makeDirectory);
    function makeDirectory(mode, a) {
        return function () {
            var $do$op = exists(path.join(a, '..'));
            var $do$type = $do$op.of || $do$op.constructor.of;
            return $do$op.chain(function (flag) {
                if (flag) {
                    return function () {
                        return mkdir(a);
                    }();
                } else {
                    return function () {
                        var $do$op$2 = makeDirectory(mode, path.join(a, '..'));
                        var $do$type$2 = $do$op$2.of || $do$op$2.constructor.of;
                        return $do$op$2.chain(function (_it) {
                            return makeDirectory(mode, a);
                        });
                    }();
                }
            });
        }();
        function mkdir(a$2) {
            return new Future(function (reject, resolve) {
                fs.mkdir(a$2, function (err, data) {
                    if (err)
                        reject(err);
                    else
                        resolve(data);
                });
            }.bind(this));
        }
    }
    exports.listDirectory = listDirectory;
    function listDirectory(a) {
        return new Future(function (reject, resolve) {
            fs.readdir(a, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    exports.listDirectoryRecursively = listDirectoryRecursively;
    function listDirectoryRecursively(a) {
        return function () {
            var $do$op = listDirectory(a).map(function (a$2) {
                return a$2.map(prepend(a));
            });
            var $do$type = $do$op.of || $do$op.constructor.of;
            return $do$op.chain(function (contents) {
                return filterM(Future, isFile, contents).chain(function (files) {
                    return filterM(Future, isDirectory, contents).chain(function (dirs) {
                        return parallel(dirs.map(listDirectoryRecursively)).chain(function (children) {
                            return $do$type(files.concat(flatten(children)));
                        });
                    });
                });
            });
        }();
    }
    exports.move = curry(2, move);
    function move(a, b) {
        return new Future(function (reject, resolve) {
            mv({ clobber: true }, a, b, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        }.bind(this));
    }
    return exports;
};
//# sourceMappingURL=index.js.map